package logical;

import java.util.Scanner;

/**
 * 题目描述
 * 如果矩阵中的许多系数都为零，那么该矩阵就是稀疏的。对稀疏现象有兴趣是因为它的开发可以带来巨大的计算节省，并且在许多大的实践中都会出现矩阵稀疏的问题。
 * 给定一个矩阵，现在需要逐行和逐列地扫描矩阵，如果某一行或者某一列内，存在连续出现的0的个数超过了行宽或者列宽的一半 [W /2] (整除) ，
 * 则认为该行或者该列是稀疏的。
 * 扫描给定的矩阵，输出稀疏的行数和列数。
 *
 * 输入描述
 * 第一行输入为M和N，表示矩阵的大小M*N，0 ＜ M ≤ 100，0 ＜ N ≤ 100
 * 接下来M行输入为矩阵的成员，每行N个成员，矩阵成员都是有符号整数，范围-32,768到32,767
 *
 * 输出描述
 * 输出两行，第一行表示稀疏行的个数，第二行表示稀疏列的个数
 *
 * 用例1
 * 输入
 *
 * 3 3
 * 1 0 0
 * 0 1 0
 * 0 0 1
 * 1
 * 2
 * 3
 * 4
 * 输出
 * 3
 * 3
 * 给定的3*3矩阵里，每一行和每一列内都存在2个0，行宽3，列宽3，[3/2] = 1，因此稀疏行有3个，稀疏列有3个。
 *
 * 用例2
 * 输入
 * 5 3
 * -1 0 1
 * 0 0 0
 * -1 0 0
 * 0 -1 0
 * 0 0 0
 * 输出
 * 5
 * 3
 * 给定的5*3矩阵，每行里面0的个数大于等于1表示稀疏行，每列里面0的个数大于等于2表示稀疏行，所以有5个稀疏行,3个稀疏列。
 *
 * 解题思路
 * 根据题目要求，如果某一行或某一列中连续出现的0的个数超过了行宽或列宽的一半（整除），则该行或该列被认为是稀疏的。
 * 然而，在用例中确认稀疏行和稀疏列时，并不是基于连续0的个数。
 *  1.首先，根据输入描述，我们需要先读取矩阵的大小M和N，然后创建两个数组rowZeroCount和colZeroCount，分别用于记录每一行和每一列中0的个数。
 *  2.接下来，我们需要使用两个嵌套的循环来遍历矩阵的每一个元素。对于每一个元素，如果它的值为0，就将相应的行和列的计数器加1。
 *  3.在循环结束后，我们 筛选出满足条件的计数器的个数。
 *      对于rowZeroCount数组，我们要找出其中大于等于n/2的元素个数；
 *      对于colZeroCount数组，我们要找出其中大于等于m/2的元素个数。
 *  4.最后，我们将得到的结果打印输出即可。
 *
 * 整体的代码思路如下：
 *
 * 读取矩阵的大小M和N；
 * 创建两个数组rowZeroCount和colZeroCount，用于记录每一行和每一列中0的个数；
 * 使用两个嵌套的循环遍历矩阵的每一个元素，如果元素的值为0，则将相应的行和列的计数器加1；
 * 法筛选出满足条件的计数器的个数；
 * 打印输出满足条件的行数和列数。
 * ————————————————
 * 版权声明：本文为CSDN博主「算法大师」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
 * 原文链接：https://blog.csdn.net/banxia_frontend/article/details/131098534
 */
/*
3 3
1 0 0
0 1 0
0 0 1

4 4
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0

2 2
1 0
0 1

3 4
1 0 0 0
0 1 0 0
0 0 1 0

10 10
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0

 */
public class SparseMatrix {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // 输入矩阵的大小
        int rowCount = scanner.nextInt(); // 矩阵的行数
        int colCount = scanner.nextInt(); // 矩阵的列数

        // 用于记录每一行和每一列中0的个数
        int[] rowZeroCount = new int[rowCount]; // 记录每一行中0的个数
        int[] colZeroCount = new int[colCount]; // 记录每一列中0的个数

        // 扫描矩阵，统计每一行和每一列中0的个数
        for (int i = 0; i < rowCount; i++) {
            for (int j = 0; j < colCount; j++) {
                int num = scanner.nextInt(); // 输入矩阵中的成员
                if (num == 0) {
                    rowZeroCount[i]++; // 如果成员为0，则该行的0的个数加1
                    colZeroCount[j]++; // 如果成员为0，则该列的0的个数加1
                }
            }
        }

        // 统计稀疏行的个数
        int sparseRowCount = 0; // 记录稀疏行的个数
        for (int i = 0; i < rowCount; i++) {
            if (rowZeroCount[i] >= colCount / 2) { // 如果该行的0的个数超过了列宽的一半
                sparseRowCount++; // 稀疏行的个数加1
            }
        }

        // 统计稀疏列的个数
        int sparseColCount = 0; // 记录稀疏列的个数
        for (int j = 0; j < colCount; j++) {
            if (colZeroCount[j] >= rowCount / 2) { // 如果该列的0的个数超过了行宽的一半
                sparseColCount++; // 稀疏列的个数加1
            }
        }

        // 输出稀疏行的个数和稀疏列的个数
        System.out.println(sparseRowCount); // 输出稀疏行的个数
        System.out.println(sparseColCount); // 输出稀疏列的个数
    }
}

